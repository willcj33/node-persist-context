"use strict";

var moment = require('moment');
var fluent = require('fluent-logger');
var fluentContainer = {
    isConfigured: false,
    fluentObject: fluent
};
var colors = require('colors');

module.exports = {};

function jsonFormatter(log) {
    let output = {};
    for (let i = 0; i < log.logs.length; i++) {
        let l = log.logs[i];
        switch (l.type) {
            case 'string':
                output[l.key] = l.value;
                break;
            case 'long':
                output[l.key + '<long>'] = l.value;
                break;
            case 'timestamp':
                output[l.key + '<ts>'] = l.value;
                break;
            case 'int':
                if (l.key === 'level') {
                    output[l.key] = LEVELS_LOOKUP[l.value];
                } else {
                    output[l.key + '<int>'] = l.value;
                }
                break;
            case 'bool':
                output[l.key + '<bool>'] = l.value;
                break;
            case 'blob':
                output[l.key] = l.value;
                break;
            case 'float':
                output[l.key + '<float>'] = l.value;
                break;
            case 'double':
                output[l.key + '<double>'] = l.value;
                break;
        }
    }
    return output;
}

function singleStringFormatter(log) {
    let formattedArr = [];
    for (let l of log) {
        let s = l.key;
        switch (l.type) {
            case 'string':
                s += '="' + l.value.replace(/\"/g, '\\"') + '"';
                break;
            case 'long':
            case 'timestamp':
                s += '.' + l.type + '="' + this.value + '"';
                break;
            case 'int':
                s += '.' + l.type + '=' + this.value;
                break;
            case 'bool':
                s += '=' + this.value;
                break;
            case 'blob':
                s += '="' + JSON.stringify(this.value).replace(/\"/g, '\\"') + '"';
                break;
        }
        formattedArr.push(s);
    }
    return formattedArr.join(',').replace(/\n/g, '\\n').replace(/\r/g, '\\r');
}

function multiStringFormatter(log) {
    let formattedArr = [];
    for (let l of log) {
        let s = l.key;
        switch (l.type) {
            case 'string':
                s += '="' + l.value.replace(/\"/g, '\\"') + '"';
                break;
            case 'long':
            case 'timestamp':
                s += '.' + l.type + '="' + this.value + '"';
                break;
            case 'int':
                s += '.' + l.type + '=' + this.value;
                break;
            case 'bool':
                s += '=' + this.value;
                break;
            case 'blob':
                s += '="' + JSON.stringify(this.value).replace(/\"/g, '\\"') + '"';
                break;
        }
        formattedArr.push(s);
    }
    return formattedArr.join(',');
}

class BaseLogWriter {
    constructor(minLevel) {
        this.minLevel = minLevel || LEVELS.INFO;
    }

    _customWrite(msg) {
        console.log(msg);
    }

    write(level, msg) {
        if (level >= this.minLevel) {
            this._customWrite(msg);
        }
    }
}

class FluentLogWriter extends BaseLogWriter {
    constructor(minLevel, config) {
        super(minLevel);

        if (!fluentContainer.isConfigured && config.host && config.port) {
            fluentContainer.isConfigured = true;
            fluentContainer.fluentObject.configure('lumberjack', {
                host: process.env.FLUENTD_FORWARDER_V2_SERVICE_HOST || process.env.FLUENTD_V0_SERVICE_HOST || config.host,
                port: process.env.FLUENTD_FORWARDER_V2_SERVICE_PORT || process.env.FLUENTD_V0_SERVICE_PORT || config.port,
                timeout: process.env.LOGGER_SERVICE_FLUENT_TIMEOUT || config.timeout
            });
        }
    }

    _customWrite(msg) {

        if (fluentContainer.isConfigured) {
            fluentContainer.fluentObject.emit(msg['level'].toLowerCase(), msg);
        }
    }
}

class PrettyLogWriter extends BaseLogWriter {
    constructor(minLevel) {
        super(minLevel);
    }

    _customWrite(msg) {
        let prettyLog = '';
        prettyLog += '['.green + moment(msg['timestamp']).format("YYYY-MM-DD h:mm:ss:SSS a").green + ']'.green + ' ';
        switch (msg['level']) {
            case LEVELS_LOOKUP[10]:
                prettyLog += msg['level'].grey;
                if (msg.message) {
                    prettyLog += ' ' + msg.message.replace(/\n/g, '\\n').replace(/\r/g, '\\r').grey;
                }
                break;
            case LEVELS_LOOKUP[20]:
                prettyLog += msg['level'].blue;
                if (msg.message) {
                    prettyLog += ' ' + msg.message.replace(/\n/g, '\\n').replace(/\r/g, '\\r').blue;
                }
                break;
            case LEVELS_LOOKUP[30]:
                prettyLog += msg['level'].cyan;
                if (msg.message) {
                    prettyLog += ' ' + msg.message.replace(/\n/g, '\\n').replace(/\r/g, '\\r').cyan;
                }
                break;
            case LEVELS_LOOKUP[40]:
                prettyLog += msg['level'].yellow;
                if (msg.message) {
                    prettyLog += ' ' + msg.message.replace(/\n/g, '\\n').replace(/\r/g, '\\r').yellow;
                }
                break;
            case LEVELS_LOOKUP[50]:
                prettyLog += msg['level'].red;
                if (msg.message) {
                    prettyLog += ' ' + msg.message.replace(/\n/g, '\\n').replace(/\r/g, '\\r').red;
                }
                break;
            case LEVELS_LOOKUP[60]:
                prettyLog += msg['level'].magenta;
                if (msg.message) {
                    prettyLog += ' ' + msg.message.replace(/\n/g, '\\n').replace(/\r/g, '\\r').magenta;
                }
                break;
        }
        for (let k in msg) {
            if (msg.hasOwnProperty(k)) {
                if (k != 'timestamp' && k != 'level' && k != 'message' && k != 'stacktrace') {
                    prettyLog += '\n\t' + k.cyan + ':'.cyan + ' ' + msg[k];
                }
            }
        }
        if (msg.hasOwnProperty('stacktrace')) {
            prettyLog += '\n\n' + msg.stacktrace.red;
        }
        console.log(prettyLog);
    }
}

class Lumberjack {
    constructor(name, config, baseOptions) {
        this._config = config;
        this._name = name;
        this._service = config.service;
        this._otherBaseLogs = [];
        if (baseOptions) {
            if (baseOptions instanceof LogClause) {
                this._otherBaseLogs.push(baseOptions);
            } else if (Array.isArray(baseOptions) && baseOptions[0] instanceof LogClause) {
                this._otherBaseLogs = baseOptions;
            }
        }
        if (config.loggers && Array.isArray(config.loggers) && config.loggers.length > 0) {
            let self = this;
            self._loggers = [];
            for (let i = 0; i < config.loggers.length; i++) {
                let lofi = config.loggers[i];
                self._loggers.push(new lofi.type(process.env.LOGGER_SERVICE_MIN_LEVEL || lofi.minLevel || LEVELS.INFO, lofi.config));
            }
        }
        this.format = config.formatter || FORMATTERS.JSON;
    }

    _createBaseLog() {
        let newLog = new Log([
            new LogClause('logger', TYPES.STRING, this._name),
            new LogClause('service', TYPES.STRING, this._service)
        ]);
        if (this._otherBaseLogs && Array.isArray(this._otherBaseLogs)) {
            newLog._add(this._otherBaseLogs);
        }
        return newLog;
    }

    _writeLog(level, msg) {
        let self = this;
        for (let i = 0; i < self._loggers.length; i++) {
            self._loggers[i].write(level, msg);
        }
        msg = null;
    }

    _levelLog(level, o) {
        if (o instanceof Log) {
            o.addInt('level', level);
            o.addTimestamp('timestamp', new Date().getTime());
            this._writeLog(level, this.format(o));
            o = null;
        } else {
            let newLog = this._createBaseLog();
            if (typeof o === 'string') {
                newLog.addString('message', o);
            } else if ((o instanceof LogClause) || (Array.isArray(o) && o[0] instanceof LogClause)) {
                newLog._add(o);
            } else if (o instanceof Error) {
                newLog.addString('message', o.message);
                newLog.addString('stacktrace', o.stack);
            }
            newLog.addInt('level', level);
            newLog.addTimestamp('timestamp', new Date().getTime());
            this._writeLog(level, this.format(newLog));
            newLog = null;
            o = null;
        }
    }

    createLog() {
        return this._createBaseLog();
    }

    createChildLogger(name, o) {
        let newBaseLogs = (o) ? this._otherBaseLogs.concat(o) : this._otherBaseLogs;
        return new Lumberjack(this._name + '.' + name, {
            service: this._service,
            loggers: this._config.loggers
        }, newBaseLogs);
    }

    trace(o) {
        this._levelLog(LEVELS.TRACE, o);
    }

    debug(o) {
        this._levelLog(LEVELS.DEBUG, o);
    }

    info(o) {
        this._levelLog(LEVELS.INFO, o);
    }

    warn(o) {
        this._levelLog(LEVELS.WARN, o);
    }

    error(o) {
        this._levelLog(LEVELS.ERROR, o);
    }

    fatal(o) {
        this._levelLog(LEVELS.FATAL, o);
    }

    log(o) {
        if (o instanceof Error) {
            this.error(o);
        } else {
            this.info(o);
        }
    }
}

class Log {
    constructor(keyVals) {
        this.logs = [];
        if (Array.isArray(keyVals) && keyVals[0] instanceof LogClause) {
            this.logs = keyVals;
        } else if (keyVals instanceof LogClause) {
            this.logs.push(keyVals);
        }
    }

    _find(key) {
        for (let i = 0; i < this.logs.length; i++) {
            let l = this.logs[i];
            if (l.key == key) {
                return i;
            }
        }
        return -1;
    }

    _add(keyval, type, val) {
        if (typeof keyval === 'string') {
            let idx = this._find(keyval);
            if (idx > -1) {
                this.logs[idx] = new LogClause(keyval, type, val);
            } else {
                this.logs.push(new LogClause(keyval, type, val));
            }
        } else if (Array.isArray(keyval) && keyval[0] instanceof LogClause) {
            this.logs = this.logs.concat(keyval);
        } else if (keyval instanceof LogClause) {
            let idx = this._find(keyval);
            if (idx > -1) {
                this.logs[idx] = keyval;
            } else {
                this.logs.push(keyval);
            }
        } else {
        }
    }

    addLong(key, val) {
        this._add(key, TYPES.LONG, val);
        return this;
    }

    addFloat(key, val) {
        this._add(key, TYPES.FLOAT, val);
        return this;
    }

    addDouble(key, val) {
        this._add(key, TYPES.DOUBLE, val);
        return this;
    }

    addString(key, val) {
        this._add(key, TYPES.STRING, val);
        return this;
    }

    addInt(key, val) {
        this._add(key, TYPES.INT, val);
        return this;
    }

    addBlob(key, val) {
        this._add(key, TYPES.BLOB, val);
        return this;
    }

    addTimestamp(key, val) {
        this._add(key, TYPES.TIMESTAMP, val);
        return this;
    }
}

class LogClause {
    constructor(key, type, value) {
        this._key = key;
        this._type = type;
        this._value = value;
    }

    get key() {
        return this._key;
    }

    get type() {
        return this._type;
    }

    get value() {
        return this._value;
    }

    set key(newVal) {
        this._key = newVal;
    }

    set type(newVal) {
        this._type = newVal;
    }

    set value(newVal) {
        this._value = newVal;
    }
}

const LEVELS = {
    TRACE: 10,
    DEBUG: 20,
    INFO: 30,
    WARN: 40,
    ERROR: 50,
    FATAL: 60
};

const LEVELS_LOOKUP = {
    10: 'TRACE',
    20: 'DEBUG',
    30: 'INFO',
    40: 'WARN',
    50: 'ERROR',
    60: 'FATAL'
};

const TYPES = {
    STRING: 'string',
    LONG: 'long',
    INT: 'int',
    TIMESTAMP: 'timestamp',
    BOOL: 'bool',
    BLOB: 'blob',
    FLOAT: 'float',
    DOUBLE: 'double'
};

const LOGGERS = {
    STANDARD: BaseLogWriter,
    FLUENT: FluentLogWriter,
    PRETTY: PrettyLogWriter
};

const FORMATTERS = {
    JSON: jsonFormatter,
    SINGLE_STRING: singleStringFormatter,
    MULTI_STRING: multiStringFormatter
};

//module.exports.LEVELS = LEVELS;
module.exports.TYPES = TYPES;
module.exports.LOGGERS = LOGGERS;
module.exports.FORMATTERS = FORMATTERS;
module.exports.LEVELS = LEVELS;
module.exports.Lumberjack = Lumberjack;
//module.exports.Log = Log;
module.exports.LogClause = LogClause;
