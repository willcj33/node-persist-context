#Geofeedia-Server
This project is a very simple abstraction of a typical restify node server into a single class providing most of what you need to create a new node http service. This package takes care of most of the boilerplate of setting up a new service with things like logging, error handling, common middleware, and other enviroment variable configurations.
 
##Installation
First, make sure you have set your default npm registry on your local machine to our private sinopia npm server. Then run `npm install --save geofeedia-server`.

##Usage
```javascript
const BaseService = require('geofeedia-server.js');
const testRoutes = require('./my-custom-routes.js');

//Instantiate a new BaseService (the geofeedia-server class) with any desired available configurations.
const service = new BaseService({
  serviceName: "test-service",
  version: "0.1.0",
  host: "127.0.0.1",
  port: 8083,
  logging: {
    loggers: "pretty",
    pretty: {
      minLevel: 30
    }
  }
});

//This allows you to register any custom middleware
service.registerMiddleware((req, res, next) => {
    req.params.foo = 'bar';
    next();
});

//This allows you to register your custom routes to the service
service.register(testRoutes);

//This starts the service running on the configured host and port (defaults to 127.0.0.1:8083)
service.start();
```

##Reference
The geofeedia-server package exports a single class (named Service). This class has a constructor which takes a configuration object which is used to set up the server, configure logging, and more.
The possible configurations are: 
```
serviceName: 'generic-service',
version: '0.1.0',
host: '127.0.0.1',
port: 8083,
logging: {
    //A comma delimited list of log writers you want to use
    loggers: 'fluent,pretty',
    //Each desired log writer should be configured here, using the name of the log writer as the key.
    fluent: {
        host: "localhost",
        port: 8077,
        timeout: 3.0,
        minLevel: 30
    },
    pretty: {
        minLevel: 30
    }
}
```
Once your service object is created, there 4 methods available: `.registerMiddleware(<middlewareFunction>)`, `.register(<routes>)`, `.start()`, and `.close()`.
Each of these methods will return `this` and can be chained.
When registering a middleware, simply pass a function like the following: `function (req, res, next) { //some code here... }`. The function will get passed the request object, the response object, and a callback which needs to be called at the end of your middleware. This is the exact same as a normal restify middleware function.
When registering a route, there are 2 ways to pass in your routes. The first way looks like this:
```javascript
const routes = {
    register: function (server) {
        server.get('/test', function (req, res, next) {
            res.send(200);
        });    
    }
};

service.register(routes);
```
With the first way, you pass an object with a register function which receives the reference to the actual restify server, where you can then add restify routes as you would in a restify server normally.
The second way abstracts the need to have a reference to the server and can be more flexible. This is also the recommended way to define your routes. The second option routes looks like this:
```javascript
const BaseService = require('geofeedia-server');

const routes = [
   {
       type: BaseService.ACTION_TYPES.GET, //or you can simply pass a lower case http action such as 'get'.
       route: '/test',
       schema: {}, //This is a jsonSchema (kind of). This is used to validate the parameters of your route.
       handler: function (req, res, next) {
           res.send(200);       
       }
   }
];

service.register(routes);
```
Notice with this way of passing routes, you instead send an array of objects which then define the routes by specifying the `type`, the `route`, an optional `schema`, and the `handler` function that will be called when that route is hit.
Also notice that the service class comes with an Enum providing the available http action types.
Next, there is the `.start()` method which starts the server, listening on the configured host and port.
Last, there is the `.close()` method which stops the server listening on the configured host and port.

##Schema Validation
As is shown in the second way to pass routes, you can provide a pseudo-jsonschema which will be used to validate the parameters sent to that route. If the validation passes, the request will go through the route handler function normally. However, if the validation fails, then the server will automatically send a `400 Bad Request.` response. 
As I alluded to earlier in this explanation, the provided schema is very similar to jsonschema (and at some point I might just implement the jsonschema spec more fully). The following is an example of a schema showing all options:
```javascript
{
  "type": "object", // The type of var to be validated. The following types are available: "object", "array", "number", "string", "date", "bool".
  "required": true, // Whether or not this var is required.
  "properties": {
    "aNumber": {
      "type": "number", // Evaluated with !Number.isNaN(parseInt(val))
      "required": true,
      "min": 0, // The lower limit for the provided number. Will be evaluated `min <= val`
      "max": 100, // The upper limit for the provided number. Will be evaluated `max >= val`
      "oneOf": [ 1 , 2 , 3 , 5 , 7 , 11 , 13 , 17 ] // Will make sure the provided value intersects with a value in the provided list
    },
    "aString": {
      "type": "string", // Evaluated with typeof val === 'string'
      "required": true,
      "minLength": 1, // The lower length limit for the provided string. Will be evaluated `min <= val.length`
      "maxLength": 20, // The upper length limit for the provided string. Will be evaluated `max >= val.length`
      "pattern": "^Hello\\s{1}[a-zA-Z]+$", // A pattern to use as regex validation against the provided value
      "oneOf": [] // Same as for number
    },
    "aDate": {
      "type": "date", // Evaluated with moment(val).isValid()
      "required": true,
      "minDate": "", // The min date. Is evaluated with moment(val).isAfter(minDate)
      "maxDate": "", // The max date. Is evaluated with moment(val).isBefore(maxDate)
      "oneOf": [] // Same as for number
    },
    "aBool": {
      "type": "bool", // Evaluated with typeof val === 'boolean'
      "required": true
    },
    "anArray": {
      "type": "array", //Evaluated with Array.isArray(val)
      "required": true,
      "minItems": 0, // The lower length limit for the provided array. Will be evaluated `min <= val.length`
      "maxItems": 10, // The upper length limit for the provided array. Will be evaluated `max >= val.length`
      "items": { // The schema which will be applied to all children in the array
        "type": "number",
        "required": true,
        //whatever else...
      }
    },
    "anObject": {
      "type": "object", // Evaluated with typeof val === 'object' && !Array.isArray(val) (null is already filtered out by required validation pieces)
      "required": true,
      "properties": {
        // The properties of the object followed by their respective schemas
      }
    }
  }
}
```

##Tests
The following tests are available:
  * `mocha -u tdd tests\tests.js`
  * `mocha -u tdd tests\test-functional.js`

## Contributing

1. Create your feature branch: `git checkout -b my-new-feature`
2. Commit your changes: `git commit -am 'Add some feature'`
3. Push to the branch: `git push origin my-new-feature`
4. Submit a pull request :D

##Authors
alex.hester@geofeedia.com
